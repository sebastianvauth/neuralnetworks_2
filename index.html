<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Das Neuron – Biologische Inspiration & Künstliches Modell</title>
    <style>
        /* CSS remains the same */
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #ffffff;
            font-size: 150%;
        }
        section {
            margin-bottom: 20px;
            padding: 20px;
            background-color: #ffffff;
            display: none;
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }
        h1, h2, h3, h4 {
            color: #333;
            margin-top: 20px;
        }
        p, li {
            line-height: 1.6;
            color: #444;
            margin-bottom: 20px;
        }
        ul {
            padding-left: 20px;
        }
        .image-placeholder, .interactive-placeholder, .continue-button, .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think, .math-explainer {
            text-align: left;
        }
        .image-placeholder img, .interactive-placeholder img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }
        .vocab-section, .why-it-matters, .test-your-knowledge, .faq-section, .stop-and-think, .math-explainer {
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .vocab-section {
            background-color: #f0f8ff;
        }
        .vocab-section h3 {
            color: #1e90ff;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .vocab-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .vocab-term {
            font-weight: bold;
            color: #1e90ff;
        }
        .why-it-matters {
            background-color: #ffe6f0;
        }
        .why-it-matters h3 {
            color: #d81b60;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .stop-and-think {
            background-color: #e6e6ff;
        }
        .stop-and-think h3 {
            color: #4b0082;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .continue-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #007bff;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .reveal-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #4b0082;
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
        }
        .test-your-knowledge {
            background-color: #e6ffe6; /* Light green background */
        }
        .test-your-knowledge h3 {
            color: #28a745; /* Dark green heading */
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .test-your-knowledge h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .test-your-knowledge p {
            margin-bottom: 15px;
        }
        .check-button {
            display: inline-block;
            padding: 10px 20px;
            margin-top: 15px;
            color: #ffffff;
            background-color: #28a745; /* Green background */
            border-radius: 5px;
            text-decoration: none;
            cursor: pointer;
            border: none;
            font-size: 1em;
        }
        .faq-section {
            background-color: #fffbea; /* Light yellow background */
        }
        .faq-section h3 {
            color: #ffcc00; /* Bright yellow heading */
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .faq-section h4 {
            color: #000;
            font-size: 0.9em;
            margin-top: 10px;
            margin-bottom: 8px;
        }
        .math-explainer {
            background-color: #f5f5f5; /* Light gray background */
            border-left: 4px solid #007bff;
        }
        .math-explainer h3 {
            color: #007bff;
            font-size: 0.75em;
            margin-bottom: 5px;
            margin-top: 5px;
        }
        .math-explainer .step {
            margin-bottom: 10px;
            padding-left: 20px;
        }
        .math-explainer .formula {
            text-align: center;
            margin: 15px 0;
            font-size: 1.2em;
        }
        .option {
            margin-bottom: 10px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            cursor: pointer;
        }
        .option:hover {
            background-color: #f9f9f9;
        }
        .option.selected {
            border-color: #28a745;
            background-color: #e6ffe6;
        }
        .option-feedback {
            display: none;
            margin-top: 5px;
            padding: 10px;
            border-radius: 5px;
        }
        .option-feedback.correct {
            background-color: #d4edda;
            color: #155724;
        }
        .option-feedback.incorrect {
            background-color: #f8d7da;
            color: #721c24;
        }
        .interactive-neuron {
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .interactive-neuron .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .interactive-neuron .control-group {
            flex: 1;
            min-width: 200px;
        }
        .interactive-neuron label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .interactive-neuron input[type="number"] {
            width: 60px;
            padding: 5px;
            margin-right: 10px;
        }
        .interactive-neuron input[type="range"] {
            width: 100%;
        }
        .interactive-neuron .calculation {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        .interactive-neuron .output {
            font-weight: bold;
            color: #007bff;
            font-size: 1.2em;
        }
         /* Style for inline MathJax */
        mjx-container {
            display: inline !important; /* Ensure MathJax behaves inline */
        }
    </style>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
    <section id="section1">
        <div class="image-placeholder">
            <img src="images/1.png?height=300&width=600" alt="...">
        </div>
        <h1>Das Neuron: Biologische Inspiration & Künstliches Modell</h1>
        
        <p>In der letzten Lektion haben wir die unglaublichen Möglichkeiten neuronaler Netze gesehen. Aber was <em>sind</em> sie eigentlich? Im Kern sind sie von den biologischen Netzwerken in unseren Gehirnen inspiriert, die aus Zellen namens <strong>Neuronen</strong> bestehen.</p>
        <div class="continue-button" onclick="showNextSection(2)">Weiter</div>
    </section>

    <section id="section2">
<!-- Start: Looping Neuron Animation (Compact) -->
<div id="looping-neuron-animation-compact">

    <style>
        /* Scoped styles */
        #looping-neuron-animation-compact {
            font-family: Arial, sans-serif;
            padding: 0; /* No padding needed for the container */
            background-color: #ffffff;
            font-size: 100%;
            /* border: 1px solid #eee; */ /* Frame/border removed */
            border-radius: 8px; /* Keep rounding if desired, or remove */
            overflow: hidden;
            margin: 20px auto;
            max-width: 550px; /* Reduced max-width slightly */
            position: relative;
        }

        #looping-neuron-animation-compact svg {
            display: block;
            width: 100%;
            height: auto;
             /* Ensure SVG scales correctly without extra space */
            overflow: visible; /* Keep allowing labels outside viewbox if needed, but position them better */
        }

        /* Neuron Parts */
        #looping-neuron-animation-compact .neuron-part { fill: #e0eaf5; stroke: #6a9bc3; stroke-width: 1.5; }
        #looping-neuron-animation-compact .nucleus { fill: #6a9bc3; stroke: none; }

        /* Labels (Always Visible, Smaller, Repositioned) */
        #looping-neuron-animation-compact .label {
            font-size: 11px; /* Significantly smaller font size */
            font-weight: bold;
            fill: #555; /* Slightly darker grey */
            text-anchor: middle;
            dominant-baseline: middle; /* Better vertical centering */
            pointer-events: none;
            font-family: Arial, sans-serif;
            opacity: 1;
        }

        /* Signal Styles (Unchanged) */
        #looping-neuron-animation-compact .signal-dot { fill: #ffb84d; stroke: #e69500; stroke-width: 0.5; pointer-events: none; visibility: hidden; }
        #looping-neuron-animation-compact .soma-pulse-dot { fill: #ffe066; stroke: #cca300; pointer-events: none; visibility: hidden; opacity: 0.8; }
    </style>

    <svg id="neuron-svg-compact" viewBox="0 0 400 250"> <!-- ViewBox remains the same, positioning is internal -->
        <defs>
            <!-- Paths (Unchanged) -->
            <path id="signal-path-dendrite-1-compact" d="M 20,60 Q 50,70 100,80" stroke="none" fill="none"/>
            <path id="signal-path-dendrite-2-compact" d="M 35,30 Q 60,50 100,80" stroke="none" fill="none"/>
            <path id="signal-path-dendrite-3-compact" d="M 60,10 Q 80,40 100,80" stroke="none" fill="none"/>
            <path id="signal-path-dendrite-4-compact" d="M 30,120 Q 60,100 100,80" stroke="none" fill="none"/>
            <path id="signal-path-dendrite-5-compact" d="M 60,150 Q 80,120 100,80" stroke="none" fill="none"/>
            <path id="signal-path-axon-compact" d="M 100,80 L 340,80" stroke="none" fill="none"/>
            <path id="signal-path-terminal-1-compact" d="M 340,80 Q 350,70 360,75" stroke="none" fill="none"/>
            <path id="signal-path-terminal-2-compact" d="M 340,80 Q 355,80 365,85" stroke="none" fill="none"/>
            <path id="signal-path-terminal-3-compact" d="M 340,80 Q 350,90 360,95" stroke="none" fill="none"/>
        </defs>

        <!-- Neuron Drawing Groups (Unchanged) -->
         <g id="axon-terminals-group-compact">
            <path class="neuron-part" d="M340,80 Q350,70 360,75"/> <path class="neuron-part" d="M340,80 Q355,80 365,85"/> <path class="neuron-part" d="M340,80 Q350,90 360,95"/>
            <circle class="neuron-part terminal-end" cx="360" cy="75" r="3"/> <circle class="neuron-part terminal-end" cx="365" cy="85" r="3"/> <circle class="neuron-part terminal-end" cx="360" cy="95" r="3"/>
        </g>
        <g id="axon-group-compact">
             <rect class="neuron-part myelin" x="165" y="72" width="25" height="16" rx="3"/> <rect class="neuron-part myelin" x="200" y="72" width="25" height="16" rx="3"/> <rect class="neuron-part myelin" x="235" y="72" width="25" height="16" rx="3"/> <rect class="neuron-part myelin" x="270" y="72" width="25" height="16" rx="3"/> <rect class="neuron-part myelin" x="305" y="72" width="25" height="16" rx="3"/>
             <path class="neuron-part axon-core" d="M140,80 H340" stroke-width="4"/>
        </g>
        <g id="soma-group-compact">
            <circle class="neuron-part" cx="100" cy="80" r="40"/>
            <circle class="nucleus" cx="100" cy="80" r="15"/>
        </g>
        <g id="dendrites-group-compact">
            <path class="neuron-part" d="M60,80 Q40,70 20,60"/> <path class="neuron-part" d="M65,60 Q50,40 35,30"/> <path class="neuron-part" d="M80,50 Q70,25 60,10"/>
            <path class="neuron-part" d="M70,100 Q50,110 30,120"/> <path class="neuron-part" d="M80,115 Q70,135 60,150"/>
        </g>

        <!-- Labels (Repositioned for better fit & Translated) -->
        <text id="dendrites-label-compact" class="label" x="45" y="45">Dendriten</text>      <!-- Moved more top-left -->
        <text id="soma-label-compact" class="label" x="100" y="128">Zellkörper (Soma)</text> <!-- Slightly higher -->
        <text id="axon-label-compact" class="label" x="240" y="65">Axon</text>             <!-- Moved slightly up and left -->
        <text id="axon-terminals-label-compact" class="label" x="365" y="110">Axonterminalen</text> <!-- Moved slightly higher -->

        <!-- Signal Elements (Unchanged structure, IDs updated) -->
        <circle id="signal-dendrite-1-compact" class="signal-dot" r="4"><animateMotion id="anim-dendrite-1-compact" dur="0.8s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-dendrite-1-compact"/></animateMotion></circle>
        <circle id="signal-dendrite-2-compact" class="signal-dot" r="4"><animateMotion id="anim-dendrite-2-compact" dur="0.9s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-dendrite-2-compact"/></animateMotion></circle>
        <circle id="signal-dendrite-3-compact" class="signal-dot" r="4"><animateMotion id="anim-dendrite-3-compact" dur="1.0s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-dendrite-3-compact"/></animateMotion></circle>
        <circle id="signal-dendrite-4-compact" class="signal-dot" r="4"><animateMotion id="anim-dendrite-4-compact" dur="0.85s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-dendrite-4-compact"/></animateMotion></circle>
        <circle id="signal-dendrite-5-compact" class="signal-dot" r="4"><animateMotion id="anim-dendrite-5-compact" dur="0.95s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-dendrite-5-compact"/></animateMotion></circle>
         <circle id="soma-pulse-dot-compact" class="soma-pulse-dot" cx="100" cy="80" r="5">
             <animate id="anim-pulse-radius-compact" attributeName="r" values="5; 20; 5" dur="0.4s" begin="indefinite" fill="freeze" />
             <animate id="anim-pulse-opacity-compact" attributeName="opacity" values="0.8; 1; 0.8" dur="0.4s" begin="indefinite" fill="freeze" />
         </circle>
        <circle id="signal-axon-compact" class="signal-dot" r="5">
            <animateMotion id="anim-axon-compact" dur="1.2s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-axon-compact"/></animateMotion>
        </circle>
        <circle id="signal-terminal-1-compact" class="signal-dot" r="4"><animateMotion id="anim-terminal-1-compact" dur="0.5s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-terminal-1-compact"/></animateMotion></circle>
        <circle id="signal-terminal-2-compact" class="signal-dot" r="4"><animateMotion id="anim-terminal-2-compact" dur="0.5s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-terminal-2-compact"/></animateMotion></circle>
        <circle id="signal-terminal-3-compact" class="signal-dot" r="4"><animateMotion id="anim-terminal-3-compact" dur="0.5s" begin="indefinite" fill="freeze" calcMode="linear"><mpath href="#signal-path-terminal-3-compact"/></animateMotion></circle>

    </svg>

    <script>
        // JS Logic remains the same, only SVG text was changed above
        (function() {
            // Renamed container ID
            const container = document.getElementById('looping-neuron-animation-compact');
            if (!container) return;

            // Update IDs used in script
            const dendriteDotIds = [1, 2, 3, 4, 5].map(i => `signal-dendrite-${i}-compact`);
            const dendriteAnimIds = [1, 2, 3, 4, 5].map(i => `anim-dendrite-${i}-compact`);
            const terminalDotIds = [1, 2, 3].map(i => `signal-terminal-${i}-compact`);
            const terminalAnimIds = [1, 2, 3].map(i => `anim-terminal-${i}-compact`);

            const somaPulseDotId = 'soma-pulse-dot-compact';
            const somaPulseRadiusAnimId = 'anim-pulse-radius-compact';
            const somaPulseOpacityAnimId = 'anim-pulse-opacity-compact';
            const axonDotId = 'signal-axon-compact';
            const axonAnimId = 'anim-axon-compact';

            const svg = container.querySelector('#neuron-svg-compact');

            // --- Helper Functions (Unchanged) ---
            function getElement(id) { return svg.querySelector(`#${id}`); }
            function showElement(id) { const el = getElement(id); if (el) el.style.visibility = 'visible'; }
            function hideElement(id) { const el = getElement(id); if (el) el.style.visibility = 'hidden'; }
            function beginAnimation(id) { const anim = getElement(id); if (anim && typeof anim.beginElement === 'function') try { anim.beginElement(); } catch(e) { console.error(`Cannot begin ${id}`, e)} }

            // --- Reset State (Unchanged) ---
            function resetSignalState() {
                [...dendriteDotIds, somaPulseDotId, axonDotId, ...terminalDotIds].forEach(hideElement);
            }

            // --- Animation Loop (Logic Unchanged, uses updated IDs) ---
            function runLoopIteration() {
                resetSignalState();

                // 1. Dendrites
                dendriteDotIds.forEach(showElement);
                dendriteAnimIds.forEach(beginAnimation);
                const longestDendriteAnim = getElement('anim-dendrite-3-compact'); // Use updated ID
                if (!longestDendriteAnim) { console.error("Cannot find longest dendrite animation."); return; }

                const dendriteEndListener = () => {
                    dendriteDotIds.forEach(hideElement);
                    // 2. Pulse
                    showElement(somaPulseDotId);
                    beginAnimation(somaPulseRadiusAnimId);
                    beginAnimation(somaPulseOpacityAnimId);
                    const pulseAnim = getElement(somaPulseRadiusAnimId); // Use updated ID
                    if (!pulseAnim) { console.error("Pulse anim not found"); return; }

                     const pulseEndListener = () => {
                         hideElement(somaPulseDotId);
                         // 3. Axon
                         showElement(axonDotId);
                         beginAnimation(axonAnimId);
                         const axonAnim = getElement(axonAnimId); // Use updated ID
                         if (!axonAnim) { console.error("Axon anim not found"); return; }

                         const axonEndListener = () => {
                             hideElement(axonDotId);
                             // 4. Terminals
                             terminalDotIds.forEach(showElement);
                             terminalAnimIds.forEach(beginAnimation);
                             const lastTerminalAnim = getElement(terminalAnimIds[0]); // Use updated ID
                             if (!lastTerminalAnim) { console.error("Terminal anim not found"); return; }

                             const terminalEndListener = () => {
                                  setTimeout(() => { terminalDotIds.forEach(hideElement); }, 100);
                                 // 5. RESTART LOOP
                                 setTimeout(runLoopIteration, 1000);
                                 lastTerminalAnim.removeEventListener('endEvent', terminalEndListener);
                             };
                             lastTerminalAnim.addEventListener('endEvent', terminalEndListener, { once: true });
                             axonAnim.removeEventListener('endEvent', axonEndListener);
                         };
                         axonAnim.addEventListener('endEvent', axonEndListener, { once: true });
                         pulseAnim.removeEventListener('endEvent', pulseEndListener);
                     };
                     pulseAnim.addEventListener('endEvent', pulseEndListener, { once: true });
                };
                longestDendriteAnim.addEventListener('endEvent', dendriteEndListener, { once: true });
            }

            // --- Start the loop (Unchanged) ---
            setTimeout(runLoopIteration, 500);

        })(); // Immediately invoke the function
    </script>

</div>
<!-- End: Looping Neuron Animation (Compact) -->
        <p>Stell dir ein biologisches Neuron wie einen winzigen Informationsprozessor vor. Es empfängt Signale von anderen Neuronen über seine <strong>Dendriten</strong>, verarbeitet diese Signale in seinem <strong>Zellkörper (Soma)</strong>, und wenn das kombinierte Signal stark genug ist, feuert es sein eigenes Signal entlang seines <strong>Axons</strong>, um potenziell andere Neuronen über seine <strong>Axonterminalen</strong> zu triggern.</p>
        <div class="continue-button" onclick="showNextSection(3)">Weiter</div>
    </section>

    <section id="section3">
        <h2>Das künstliche Neuron-Modell</h2>
        <p>Jetzt kommt der Clou: Wir müssen nicht <em>die ganze</em> biologische Komplexität nachbilden. Künstliche Neuronale Netze (KNNs) verwenden ein vereinfachtes mathematisches Modell, das von diesem Prozess inspiriert ist.</p>
        <p>Lernen wir das <strong>künstliche Neuron</strong> kennen (manchmal auch 'Unit' oder 'Perzeptron' genannt).</p>
        <div class="continue-button" onclick="showNextSection(4)">Weiter</div>
    </section>

    <section id="section4">
        <!-- Start: Interactive Artificial Neuron Diagram (Click Version Refined) -->
<div id="interactive-ann-diagram-click-v2">

    <style>
        /* Scoped styles for the ANN diagram (Click Version Refined) - Unchanged */
        #interactive-ann-diagram-click-v2 {
            font-family: Arial, sans-serif;
            padding: 10px 5px;
            background-color: #ffffff;
            font-size: 100%;
            border-radius: 8px;
            overflow: hidden;
            margin-bottom: 20px;
            text-align: center;
        }

        #interactive-ann-diagram-click-v2 svg {
            display: inline-block;
            width: 100%;
            max-width: 500px;
            height: auto;
            overflow: visible;
            margin-bottom: 15px;
            cursor: default;
        }

        /* Brilliant.org Inspired Styling */
        #interactive-ann-diagram-click-v2 .ann-component {
             transition: opacity 0.3s ease-in-out;
             cursor: pointer;
        }
        /* Optional fade non-highlighted - uncomment if desired
        #interactive-ann-diagram-click-v2 .ann-component:not(.highlight) {
             opacity: 0.85;
        }
        */

         /* Node Styles */
        #interactive-ann-diagram-click-v2 .input-node { fill: #d1f7ff; stroke: #00bcd4; stroke-width: 1.5; } /* Light Cyan */
        #interactive-ann-diagram-click-v2 .summation-node { fill: #fff5d4; stroke: #ffc107; stroke-width: 2; } /* Light Yellow/Amber */
        #interactive-ann-diagram-click-v2 .activation-node { fill: #fce4ec; stroke: #e91e63; stroke-width: 2; } /* Light Pink */
        #interactive-ann-diagram-click-v2 .output-node { fill: #e3f2fd; stroke: #2196f3; stroke-width: 1.5; } /* Light Blue */
        #interactive-ann-diagram-click-v2 .bias-input { fill: #f5f5f5; stroke: #9e9e9e; stroke-width: 1; } /* Light Grey for bias input '1' */

         /* Line Styles */
        #interactive-ann-diagram-click-v2 .connection-line { stroke: #90a4ae; stroke-width: 2; transition: stroke 0.2s ease, stroke-width 0.2s ease; } /* Blue Grey */
        #interactive-ann-diagram-click-v2 .bias-line { stroke: #90a4ae; stroke-width: 2; stroke-dasharray: 4, 4; transition: stroke 0.2s ease, stroke-width 0.2s ease; }

        /* Text Styles */
        #interactive-ann-diagram-click-v2 .label-text { font-family: 'Arial', sans-serif; font-size: 15px; fill: #212121; text-anchor: middle; dominant-baseline: central; pointer-events: none; }
        #interactive-ann-diagram-click-v2 .weight-text { font-family: 'Arial', sans-serif; font-size: 13px; fill: #546e7a; text-anchor: middle; pointer-events: none; font-style: italic; }
        #interactive-ann-diagram-click-v2 .subscript { font-size: 0.7em; baseline-shift: sub; }
        #interactive-ann-diagram-click-v2 .math-symbol { font-size: 22px; font-weight: normal; }
        #interactive-ann-diagram-click-v2 .bias-text { font-style: italic; font-weight: bold; }

        /* Arrowhead */
        #interactive-ann-diagram-click-v2 .arrow-marker polygon { fill: #90a4ae; transition: fill 0.2s ease; }

        /* Highlight Styles */
        #interactive-ann-diagram-click-v2 .highlight { opacity: 1 !important; }
        #interactive-ann-diagram-click-v2 .highlight .input-node,
        #interactive-ann-diagram-click-v2 .highlight .bias-input,
        #interactive-ann-diagram-click-v2 .highlight .summation-node,
        #interactive-ann-diagram-click-v2 .highlight .activation-node,
        #interactive-ann-diagram-click-v2 .highlight .output-node { stroke-width: 3; stroke: #0d47a1; } /* Dark Blue highlight stroke */

        #interactive-ann-diagram-click-v2 .highlight .connection-line,
        #interactive-ann-diagram-click-v2 .highlight .bias-line { stroke: #0d47a1; stroke-width: 3; }
        #interactive-ann-diagram-click-v2 .highlight .arrow-marker polygon { fill: #0d47a1; }

        #interactive-ann-diagram-click-v2 .highlight .weight-text,
        #interactive-ann-diagram-click-v2 .highlight .bias-text { fill: #0d47a1; font-weight: bold; }
        #interactive-ann-diagram-click-v2 .highlight .math-symbol { fill: #0d47a1; font-weight: bold; }

        /* Description Area Styles */
        #interactive-ann-diagram-click-v2 #description-ann-v2 {
             padding: 15px 20px;
             margin: 0 15px 15px 15px;
             background-color: #f8f9fa;
             border-radius: 5px;
             min-height: 6em;
             text-align: left;
             color: #444;
             line-height: 1.6;
             font-size: 1em;
             transition: background-color 0.3s ease;
        }
        #interactive-ann-diagram-click-v2 #description-ann-v2 strong { color: #333; font-weight: bold; }
        /* Style for inline MathJax was moved global */
        #interactive-ann-diagram-click-v2 #description-ann-v2 em { font-style: italic; color: #555; }

    </style>

    <svg id="ann-svg-click-v2" viewBox="0 0 350 230">
        <defs>
            <!-- Arrowhead Marker: Tip aligns with line end (refX=10) -->
            <marker id="arrowhead-ann-v2" class="arrow-marker"
                    viewBox="0 0 10 10" refX="10" refY="5"
                    markerUnits="strokeWidth" markerWidth="4" markerHeight="5"
                    orient="auto-start-reverse">
              <path d="M 0 0 L 10 5 L 0 10 z" />
            </marker>
        </defs>

        <!-- Constants -->
        <script>
            // Constants remain the same
            const NODE_RADIUS = 12; // Increased node radius
            const SUM_RADIUS = 25;
            const ACT_X = 195;
            const ACT_WIDTH = 55;
            const INPUT_CX = 35 + NODE_RADIUS; // x-coord for start of input lines
            const SUM_CX_TARGET = 125 - SUM_RADIUS; // x-coord for end of input lines
            const SUM_CX_SOURCE = 125 + SUM_RADIUS; // x-coord for start of sum->act line
            const ACT_CX_TARGET = ACT_X; // x-coord for end of sum->act line
            const ACT_CX_SOURCE = ACT_X + ACT_WIDTH; // x-coord for start of act->out line
            const OUT_CX_TARGET = 320 - NODE_RADIUS; // x-coord for end of act->out line
        </script>

        <!-- Connections (drawn first) - Unchanged -->
        <g id="connections-layer-v2">
             <!-- Input connections -->
            <line class="connection-line" id="line-input-1-v2" x1="47" y1="50" x2="100" y2="98" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2, y2 -->
            <line class="connection-line" id="line-input-2-v2" x1="47" y1="100" x2="100" y2="100" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2 -->
            <line class="connection-line" id="line-input-n-v2" x1="47" y1="150" x2="100" y2="102" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2, y2 -->
            <!-- Bias connection -->
            <line class="bias-line" id="line-bias-v2" x1="47" y1="200" x2="100" y2="104" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2, y2 -->
            <!-- Summation to Activation -->
            <line class="connection-line" id="line-sum-act-v2" x1="150" y1="100" x2="195" y2="100" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2 -->
             <!-- Activation to Output -->
            <line class="connection-line" id="line-act-out-v2" x1="250" y1="100" x2="308" y2="100" marker-end="url(#arrowhead-ann-v2)"/> <!-- Adjusted x1, x2 -->
        </g>


        <!-- Components (Click Targets) -->
        <!-- 1. Inputs -->
        <g id="inputs-group-ann-v2" class="ann-component">
             <title>Eingänge (Klicken für Details)</title>
            <circle class="input-node" cx="35" cy="50" r="12"/> <!-- Increased radius -->
            <text class="label-text" x="35" y="50">x<tspan class="subscript">1</tspan></text>

            <circle class="input-node" cx="35" cy="100" r="12"/> <!-- Increased radius -->
            <text class="label-text" x="35" y="100">x<tspan class="subscript">2</tspan></text>

            <text class="label-text" x="35" y="125" font-size="18px">.<tspan dy="3">.</tspan><tspan dy="3">.</tspan></text>

            <circle class="input-node" cx="35" cy="150" r="12"/> <!-- Increased radius -->
            <text class="label-text" x="35" y="150">x<tspan class="subscript">n</tspan></text>
        </g>

        <!-- 2. Weights (Associated with lines, clickable area around text) -->
        <g id="weights-group-ann-v2" class="ann-component">
             <title>Gewichte (Klicken für Details)</title>
            <rect x="55" y="55" width="30" height="20" fill="transparent"/>
            <rect x="55" y="95" width="30" height="20" fill="transparent"/> <!-- Adjusted y -->
            <rect x="55" y="130" width="30" height="20" fill="transparent"/>
             <!-- Weight Labels -->
            <text class="weight-text" id="text-weight-1-v2" x="70" y="65">w<tspan class="subscript">1</tspan></text>
            <text class="weight-text" id="text-weight-2-v2" x="70" y="105">w<tspan class="subscript">2</tspan></text>
            <text class="weight-text" id="text-weight-n-v2" x="70" y="140">w<tspan class="subscript">n</tspan></text>
        </g>

         <!-- 3. Bias -->
        <g id="bias-group-ann-v2" class="ann-component">
             <title>Bias (Klicken für Details)</title>
             <rect x="15" y="185" width="40" height="30" fill="transparent"/>
             <rect x="50" y="150" width="40" height="30" fill="transparent"/> <!-- Adjusted y -->

            <circle class="input-node bias-input" cx="35" cy="200" r="12"/> <!-- Increased radius -->
            <text class="label-text bias-input-label" x="35" y="200">1</text>
            <text class="weight-text bias-text" id="text-bias-v2" x="70" y="165">b</text>
        </g>

        <!-- 4. Summation -->
        <g id="summation-group-ann-v2" class="ann-component">
             <title>Summationsfunktion (Klicken für Details)</title>
            <circle class="summation-node" cx="125" cy="100" r="25"/>
            <text class="label-text math-symbol summation-symbol" x="125" y="100">Σ</text>
        </g>

        <!-- 5. Activation Function -->
        <g id="activation-group-ann-v2" class="ann-component">
             <title>Aktivierungsfunktion (Klicken für Details)</title>
            <rect class="activation-node" x="195" y="75" width="55" height="50" rx="8"/>
            <text class="label-text math-symbol activation-symbol" x="222.5" y="100">φ</text>
        </g>

        <!-- 6. Output -->
        <g id="output-group-ann-v2" class="ann-component">
             <title>Ausgabe (Klicken für Details)</title>
            <circle class="output-node" cx="320" cy="100" r="12"/> <!-- Increased radius -->
            <text class="label-text" x="320" y="100">a</text>
        </g>

    </svg>

    <!-- Description Area -->
    <div id="description-ann-v2">Klicke auf eine Komponente des Diagramms oben, um mehr darüber zu erfahren.</div>

    <script>
        // JS Logic updated with translated descriptions using MathJax
        (function() {
            // Unique ID for this instance
            const containerId = 'interactive-ann-diagram-click-v2';
            const container = document.getElementById(containerId);
            if (!container) return;

            const svg = container.querySelector('#ann-svg-click-v2');
            const descriptionEl = container.querySelector('#description-ann-v2');
            const allComponents = container.querySelectorAll('.ann-component');

            // Select lines by specific ID
            const lineInput1 = container.querySelector('#line-input-1-v2');
            const lineInput2 = container.querySelector('#line-input-2-v2');
            const lineInputN = container.querySelector('#line-input-n-v2');
            const lineBias = container.querySelector('#line-bias-v2');

            // Map component group IDs to **TRANSLATED** description text using MathJax
            const componentInfo = {
                'inputs-group-ann-v2': '<strong>Eingänge (\\(x_1, x_2, \\dots, x_n\\))</strong><br>Dies sind die Merkmale oder Datenpunkte, die in das Neuron eingespeist werden. Es könnten Rohdaten sein (wie Pixelwerte) oder Ausgaben von Neuronen einer vorherigen Schicht.',
                'weights-group-ann-v2': '<strong>Gewichte (\\(w_1, w_2, \\dots, w_n\\))</strong><br>Jeder Eingang \\(x_i\\) hat ein zugehöriges Gewicht \\(w_i\\). Dieser Wert bestimmt die <em>Stärke</em> oder <em>Bedeutung</em> dieses Eingangssignals. Gewichte werden typischerweise während des Trainings gelernt.',
                'bias-group-ann-v2': '<strong>Bias (\\(b\\))</strong><br>Ein zusätzlicher lernbarer Parameter, unabhängig von den Eingängen. Er wirkt wie ein Offset und erleichtert oder erschwert es dem Neuron zu aktivieren, unabhängig von den Eingangswerten. Stell es dir vor wie das Verschieben des Aktivierungsschwellenwerts.',
                'summation-group-ann-v2': '<strong>Summationsfunktion (Σ)</strong><br>Berechnet die <em>gewichtete Summe</em> (oft als \\(z\\) bezeichnet). Sie multipliziert jeden Eingang \\(x_i\\) mit seinem entsprechenden Gewicht \\(w_i\\) und addiert all diese Produkte sowie den Bias \\(b\\).<br>\\(z = (\\sum w_i x_i) + b\\)',
                'activation-group-ann-v2': '<strong>Aktivierungsfunktion (\\(\\varphi\\))</strong><br>Nimmt die gewichtete Summe (\\(z\\)) als Eingabe und wendet eine (normalerweise nichtlineare) Transformation an, um die finale Ausgabe \\(a\\) des Neurons zu erzeugen. Dies bestimmt das Feuermuster des Neurons.<br>\\(a = \\varphi(z)\\)',
                'output-group-ann-v2': '<strong>Ausgabe (\\(a\\))</strong><br>Der vom Neuron berechnete Endwert (seine Aktivierung), der dann als Vorhersage des Netzwerks verwendet oder als Eingabe an Neuronen in der nächsten Schicht weitergegeben werden kann.'
            };

            let currentlyHighlighted = null;
            let highlightedLines = []; // Keep track of lines linked to the highlighted component

            // Function to clear all highlights
            function clearHighlights() {
                 if (currentlyHighlighted) {
                     currentlyHighlighted.classList.remove('highlight');
                     currentlyHighlighted = null;
                 }
                 highlightedLines.forEach(line => line && line.classList.remove('highlight'));
                 highlightedLines = [];
            }

            // Function to update highlight and description
            function setActiveComponent(componentGroup) {
                const id = componentGroup.id;

                // Clear previous highlights first
                clearHighlights();

                // Add highlight to the clicked component group
                componentGroup.classList.add('highlight');
                currentlyHighlighted = componentGroup;

                // Highlight associated lines specifically
                 if (id === 'weights-group-ann-v2') {
                     if (lineInput1) highlightedLines.push(lineInput1);
                     if (lineInput2) highlightedLines.push(lineInput2);
                     if (lineInputN) highlightedLines.push(lineInputN);
                 } else if (id === 'bias-group-ann-v2') {
                     if (lineBias) highlightedLines.push(lineBias);
                 } else if (id === 'inputs-group-ann-v2') {
                     // Highlight lines originating FROM inputs
                      if (lineInput1) highlightedLines.push(lineInput1);
                      if (lineInput2) highlightedLines.push(lineInput2);
                      if (lineInputN) highlightedLines.push(lineInputN);
                 } else if (id === 'summation-group-ann-v2') {
                      // Highlight lines entering AND leaving summation
                      if (lineInput1) highlightedLines.push(lineInput1);
                      if (lineInput2) highlightedLines.push(lineInput2);
                      if (lineInputN) highlightedLines.push(lineInputN);
                      if (lineBias) highlightedLines.push(lineBias);
                      if (container.querySelector('#line-sum-act-v2')) highlightedLines.push(container.querySelector('#line-sum-act-v2'));
                 } else if (id === 'activation-group-ann-v2') {
                      // Highlight lines entering AND leaving activation
                       if (container.querySelector('#line-sum-act-v2')) highlightedLines.push(container.querySelector('#line-sum-act-v2'));
                       if (container.querySelector('#line-act-out-v2')) highlightedLines.push(container.querySelector('#line-act-out-v2'));
                 } else if (id === 'output-group-ann-v2') {
                      // Highlight line entering output
                       if (container.querySelector('#line-act-out-v2')) highlightedLines.push(container.querySelector('#line-act-out-v2'));
                 }

                // Apply highlight class to collected lines
                highlightedLines.forEach(line => line && line.classList.add('highlight'));


                // Update Description Text (using translated componentInfo)
                if (componentInfo[id]) {
                    descriptionEl.innerHTML = componentInfo[id];
                    // Re-render MathJax for the updated description
                    if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                        MathJax.typesetPromise([descriptionEl]);
                    }
                } else {
                    descriptionEl.innerHTML = 'Klicke auf eine Komponente des Diagramms oben, um mehr darüber zu erfahren.';
                }
            }

            // Add click listeners to all components
            allComponents.forEach(component => {
                component.addEventListener('click', (event) => {
                    event.stopPropagation(); // Prevent click bubbling
                    setActiveComponent(component);
                });
            });

            // Click on SVG background to clear selection
            svg.addEventListener('click', (event) => {
                 if (event.target === svg || event.target.closest('#connections-layer-v2')) { // Click on svg bg or lines layer
                    clearHighlights();
                    descriptionEl.innerHTML = 'Klicke auf eine Komponente des Diagramms oben, um mehr darüber zu erfahren.';
                 }
            });

             // Initialize
            descriptionEl.innerHTML = 'Klicke auf eine Komponente des Diagramms oben, um mehr darüber zu erfahren.';

        })();
    </script>

</div>
<!-- End: Interactive Artificial Neuron Diagram (Click Version Refined) -->
                <div class="continue-button" onclick="showNextSection(5)">Weiter</div>
    </section>

    <section id="section5">
        <p>Es sieht vielleicht etwas abstrakt aus, folgt aber einem ähnlichen Fluss wie das biologische Neuron: Eingabe -> Verarbeitung -> Ausgabe.</p>
                <div class="continue-button" onclick="showNextSection(6)">Weiter</div>
    </section>

    <section id="section6">
        <p>So funktioniert es mathematisch, in zwei Hauptschritten:</p>
        <div class="continue-button" onclick="showNextSection(7)">Weiter</div>
    </section>

    <section id="section7">
        <h3>Schritt 1: Die gewichtete Summe</h2>
        <p>Zuerst nimmt das Neuron seine Eingaben und berechnet eine <strong>gewichtete Summe</strong>.</p>
        <div class="math-explainer">
            <h3>Berechnung der gewichteten Summe (\(z\))</h3>
            <div class="step">
                <p><strong>1.</strong> Jeder Eingang \(x_i\) hat ein zugehöriges <strong>Gewicht</strong> \(w_i\). Stell dir das Gewicht als Kontrolle über den <em>Einfluss</em> oder die <em>Bedeutung</em> dieses spezifischen Eingangs vor. Ein großes Gewicht bedeutet, der Eingang hat eine große Wirkung; ein kleines Gewicht bedeutet, er hat weniger Wirkung.</p>
            </div>
            <div class="step">
                <p><strong>2.</strong> Wir multiplizieren jeden Eingang \(x_i\) mit seinem entsprechenden Gewicht \(w_i\).</p>
            </div>
            <div class="step">
                <p><strong>3.</strong> Wir summieren all diese gewichteten Eingänge auf: \((w_1 \cdot x_1) + (w_2 \cdot x_2) + \dots + (w_n \cdot x_n)\).</p>
            </div>
            <div class="step">
                <p><strong>4.</strong> Schließlich addieren wir einen speziellen Term namens <strong>Bias</strong> \(b\). Der Bias wirkt wie ein Offset oder ein Schwellenwert; er macht es für das Neuron einfacher oder schwerer zu aktivieren, unabhängig von den Eingängen. Es ist, als würde man fragen: 'Wie stark ist dieses Neuron sowieso schon geneigt zu feuern?'</p>
            </div>
            <div class="step">
                <p><strong>5.</strong> Das Ergebnis dieser gesamten Berechnung wird oft mit \(z\) bezeichnet. Hier ist die vollständige Formel mit Summationsnotation:</p>
            </div>
            <div class="formula">
                \[ z = \left( \sum_{i=1}^{m} w_i x_i \right) + b \]
            </div>
        </div>
       <div class="continue-button" onclick="showNextSection(8)">Weiter</div>
    </section>

    <section id="section8">
        <p>\(z\) repräsentiert also die aggregierte Signalstärke, bevor das Neuron 'entscheidet', was es ausgibt.</p>
        <div class="continue-button" onclick="showNextSection(9)">Weiter</div>
    </section>

    <section id="section9">
         <div class="vocab-section">
            <h3>Erweiter deinen Wortschatz</h3>
            <h4 class="vocab-term">Gewichte (\(w_i\))</h4>
            <p>Parameter, die jedem Eingang eines Neurons zugeordnet sind und den Einfluss des Eingangs auf die Ausgabe des Neurons bestimmen. Werden während des Trainings gelernt.</p>
            <h4 class="vocab-term">Bias (\(b\))</h4>
            <p>Ein zusätzlicher Parameter in einem Neuron, der zur gewichteten Summe der Eingänge addiert wird. Er passt den Aktivierungsschwellenwert des Neurons an und ermöglicht das Verschieben der Aktivierungsfunktion. Wird während des Trainings gelernt.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(10)">Weiter</div>
    </section>

    <section id="section10">
        <h3>Schritt 2: Die Aktivierungsfunktion</h3>
        <p>Der zweite Schritt ist der, bei dem das Neuron basierend auf dem aggregierten Signal \(z\) seine Ausgabe 'entscheidet'. Dies geschieht mithilfe einer <strong>Aktivierungsfunktion</strong>, oft bezeichnet mit \( \varphi \).</p>
        <div class="math-explainer">
            <h3>Berechnung der Ausgabe-Aktivierung (\(a\))</h3>
            <div class="step">
                <p><strong>1.</strong> Die in Schritt 1 berechnete gewichtete Summe \(z\) wird in die Aktivierungsfunktion \( \varphi \) eingespeist.</p>
            </div>
            <div class="step">
                <p><strong>2.</strong> Die Funktion \( \varphi \) transformiert \(z\) in die finale Ausgabe des Neurons, die <strong>Aktivierung</strong> \(a\) genannt wird.</p>
            </div>
            <div class="step">
                <p><strong>3.</strong> Die Ausgabe \(a\) ist also einfach:</p>
            </div>
            <div class="formula">
                \[ a = \varphi(z) \]
            </div>
        </div>
        <div class="continue-button" onclick="showNextSection(11)">Weiter</div>
    </section>

    <section id="section11">
        <p>Stell dir \( \varphi \) als den 'Abfeuermechanismus' des Neurons vor. Unterschiedliche Aktivierungsfunktionen verhalten sich unterschiedlich – einige sind einfache An/Aus-Schalter (wie das frühe TLU), andere erzeugen abgestufte Ausgaben. Wir werden spezifische Funktionen in einer späteren Lektion untersuchen.</p>
        <div class="continue-button" onclick="showNextSection(12)">Weiter</div>
    </section>

    <section id="section12">
        <div class="vocab-section">
            <h3>Erweiter deinen Wortschatz</h3>
            <h4 class="vocab-term">Aktivierungsfunktion (\( \varphi \))</h4>
            <p>Eine Funktion, die auf die gewichtete Summe (\(z\)) in einem Neuron angewendet wird, um dessen Ausgabe-Aktivierung (\(a\)) zu berechnen. Sie führt Nichtlinearitäten ein, die entscheidend für das Lernen komplexer Muster sind.</p>
            <h4 class="vocab-term">Aktivierung (\(a\))</h4>
            <p>Der Ausgabewert, der von einem Neuron erzeugt wird, nachdem die Aktivierungsfunktion auf die gewichtete Summe seiner Eingänge plus Bias angewendet wurde.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(13)">Weiter</div>
    </section>

    <section id="section13">
        <h2>Fassen wir zusammen</h2>
        <p>Wenn wir beide Schritte kombinieren, lautet die vollständige Berechnung für ein einzelnes künstliches Neuron:</p>
        <div class="math-explainer">
            <h3>Gleichung für die Neuron-Ausgabe</h3>
            <div class="formula">
                \[ a = \varphi\left( \left( \sum_{i=1}^{m} w_i x_i \right) + b \right) \]
            </div>
        </div>
        <p>Diese einfache Formel ist das Herzstück jedes künstlichen Neurons!</p>
        <div class="continue-button" onclick="showNextSection(14)">Weiter</div>
    </section>

    <section id="section14">
        <div class="why-it-matters">
            <h3>Warum ist das wichtig?</h3>
            <p>Dieses künstliche Neuron-Modell ist trotz seiner Einfachheit im Vergleich zur Biologie der fundamentale Baustein all der leistungsstarken neuronalen Netze, die wir heute sehen. Zu verstehen, wie es seine Ausgabe berechnet, ist essenziell, bevor wir sie zu Schichten verbinden.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(15)">Weiter</div>
    </section>

    <section id="section15">
        <h2>Schauen wir es uns in Aktion an!</h2>
        <p>Spiele mit den Eingangswerten und den Parametern des künstlichen Neurons und probiere verschiedene Einstellungen aus!</p>
        <!-- Start: Interactive Neuron Simulation -->
<div id="neuron-simulation">

    <style>
        /* Scoped styles for the Neuron Simulation - Unchanged */
        #neuron-simulation {
            font-family: Arial, sans-serif;
            padding: 15px;
            background-color: #ffffff;
            font-size: 100%; /* Adjust as needed relative to parent */
            border-radius: 8px;
            /* border: 1px solid #eee; */ /* Optional: uncomment to see bounds */
            margin-bottom: 20px;
            display: grid;
            grid-template-areas:
                "diagram controls"
                "output output"
                "guidance guidance";
            grid-template-columns: 1fr 1.5fr; /* Adjust ratio as needed */
            gap: 20px;
            max-width: 800px; /* Match provided body style */
            margin-left: auto;
            margin-right: auto;
        }

        /* Diagram Area */
        #neuron-simulation .diagram-area {
            grid-area: diagram;
            text-align: center;
            padding-top: 20px; /* Align visually with controls */
        }
        #neuron-simulation .diagram-area svg {
            max-width: 100%;
            height: auto;
            overflow: visible;
        }
         /* Simplified diagram styles */
        #neuron-simulation .sim-node { stroke-width: 1.5; }
        #neuron-simulation .sim-input { fill: #d1f7ff; stroke: #00bcd4; }
        #neuron-simulation .sim-sum { fill: #fff5d4; stroke: #ffc107; }
        #neuron-simulation .sim-act { fill: #fce4ec; stroke: #e91e63; }
        #neuron-simulation .sim-output { fill: #e3f2fd; stroke: #2196f3; }
        #neuron-simulation .sim-line { stroke: #90a4ae; stroke-width: 2; marker-end: url(#arrowhead-sim); }
        #neuron-simulation .sim-bias-line { stroke: #90a4ae; stroke-width: 2; stroke-dasharray: 4, 4; marker-end: url(#arrowhead-sim); }
        #neuron-simulation .sim-label { font-size: 12px; fill: #212121; text-anchor: middle; dominant-baseline: central; }
        #neuron-simulation .sim-weight { font-size: 11px; fill: #546e7a; font-style: italic; }
        #neuron-simulation .sim-sub { font-size: 0.7em; baseline-shift: sub; }
        #neuron-simulation .sim-symbol { font-size: 18px; }

        /* Controls Area */
        #neuron-simulation .controls-area {
            grid-area: controls;
            display: grid;
            grid-template-columns: auto 1fr auto; /* Label | Input/Slider | Value */
            gap: 10px 15px; /* Row gap | Column gap */
            align-items: center;
        }
        #neuron-simulation .controls-area label {
            font-weight: bold;
            text-align: right;
            font-size: 1.1em; /* Make labels slightly larger */
        }
        #neuron-simulation .controls-area input[type="number"],
        #neuron-simulation .controls-area input[type="range"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 1em;
        }
        #neuron-simulation .controls-area input[type="range"] {
             cursor: pointer;
             padding: 0; /* Remove padding for range */
        }
        #neuron-simulation .controls-area .value-display {
            font-weight: bold;
            font-family: monospace;
            min-width: 4em; /* Prevent layout shifts */
            text-align: right;
            background-color: #e9ecef;
            padding: 3px 6px;
            border-radius: 3px;
        }
        #neuron-simulation .controls-area .input-value-display { /* Style for input value display */
            font-weight: normal;
            background-color: transparent;
            padding: 0;
            min-width: auto;
        }

        /* Output Area */
        #neuron-simulation .output-area {
            grid-area: output;
            background-color: #f0f8ff; /* Like vocab-section */
            padding: 15px 20px;
            border-radius: 8px;
            font-family: monospace;
            font-size: 1.1em;
            line-height: 1.6;
            color: #333;
        }
        /* Removed code styling for output, MathJax will handle */
         #neuron-simulation .output-area .formula {
             color: #555;
             font-style: italic;
             font-size: 0.9em;
             margin-bottom: 5px;
         }


        /* Guidance Area */
        #neuron-simulation .guidance-area {
            grid-area: guidance;
            background-color: #e6e6ff; /* Like stop-and-think */
            padding: 15px 20px;
            border-radius: 8px;
            color: #444; /* Style P */
            line-height: 1.6; /* Style P */
        }
         #neuron-simulation .guidance-area h3 {
            color: #4b0082; /* Style stop-and-think h3 */
            font-size: 0.9em; /* Adjust size */
            margin-top: 0;
            margin-bottom: 10px;
         }
         /* Removed code styling for guidance, MathJax will handle */


        /* Responsive adjustments */
         @media (max-width: 650px) {
            #neuron-simulation {
                grid-template-areas:
                    "diagram"
                    "controls"
                    "output"
                    "guidance";
                grid-template-columns: 1fr; /* Single column */
            }
             #neuron-simulation .diagram-area svg { max-width: 250px; } /* Limit diagram size on small screens */
              #neuron-simulation .controls-area { grid-template-columns: auto 1fr auto; } /* Keep 3 columns for controls */
        }


    </style>

    <!-- 1. Diagram Area -->
    <div class="diagram-area">
        <svg id="sim-svg" viewBox="0 0 200 180">
            <defs>
                <marker id="arrowhead-sim" viewBox="0 0 10 10" refX="10" refY="5"
                        markerUnits="strokeWidth" markerWidth="4" markerHeight="5"
                        orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="#90a4ae"/>
                </marker>
            </defs>
            <!-- Lines - Unchanged -->
            <line class="sim-line" x1="25" y1="30" x2="70" y2="65" />
            <line class="sim-line" x1="25" y1="70" x2="70" y2="75" />
            <line class="sim-bias-line" x1="25" y1="130" x2="70" y2="85" />
            <line class="sim-line" x1="110" y1="75" x2="145" y2="75" />
            <line class="sim-line" x1="185" y1="75" x2="200" y2="75" />

            <!-- Nodes - Text content mostly symbolic, remains the same -->
            <circle class="sim-node sim-input" cx="15" cy="30" r="10"/> <text class="sim-label" x="15" y="30">x<tspan class="sim-sub">1</tspan></text>
            <circle class="sim-node sim-input" cx="15" cy="70" r="10"/> <text class="sim-label" x="15" y="70">x<tspan class="sim-sub">2</tspan></text>
            <circle class="sim-node sim-input" cx="15" cy="130" r="8"/> <text class="sim-label" x="15" y="130">1</text> <!-- Bias Input -->

            <circle class="sim-node sim-sum" cx="90" cy="75" r="20"/> <text class="sim-label sim-symbol" x="90" y="75">Σ</text>
            <rect class="sim-node sim-act" x="145" y="55" width="40" height="40" rx="5"/> <text class="sim-label sim-symbol" x="165" y="75">φ</text>
            <!-- Output Circle drawn in JS potentially -->
            <text class="sim-label" x="205" y="75">a</text>

             <!-- Weights/Bias Text - Symbolic, remains the same -->
            <text class="sim-weight" x="45" y="40">w<tspan class="sim-sub">1</tspan></text>
            <text class="sim-weight" x="45" y="75">w<tspan class="sim-sub">2</tspan></text>
            <text class="sim-weight" x="45" y="115">b</text>
        </svg>
    </div>

    <!-- 2. Controls Area -->
    <div class="controls-area">
        <!-- Input x1 -->
        <label for="input-x1">\(x_1\):</label> <!-- Using MathJax -->
        <input type="number" id="input-x1" value="1.0" step="0.1">
        <span class="value-display input-value-display">Eingabe</span>

        <!-- Input x2 -->
        <label for="input-x2">\(x_2\):</label> <!-- Using MathJax -->
        <input type="number" id="input-x2" value="-0.5" step="0.1">
         <span class="value-display input-value-display">Eingabe</span>

        <!-- Weight w1 -->
        <label for="slider-w1">\(w_1\):</label> <!-- Using MathJax -->
        <input type="range" id="slider-w1" min="-2" max="2" value="0.8" step="0.1">
        <span id="value-w1" class="value-display">0.8</span>

        <!-- Weight w2 -->
        <label for="slider-w2">\(w_2\):</label> <!-- Using MathJax -->
        <input type="range" id="slider-w2" min="-2" max="2" value="1.2" step="0.1">
        <span id="value-w2" class="value-display">1.2</span>

        <!-- Bias b -->
        <label for="slider-b">\(b\):</label> <!-- Using MathJax -->
        <input type="range" id="slider-b" min="-2" max="2" value="-0.5" step="0.1">
        <span id="value-b" class="value-display">-0.5</span>
    </div>

    <!-- 3. Output Display Area -->
    <div class="output-area">
        <!-- Updated formula with MathJax -->
        <div class="formula">\(z = (w_1 \cdot x_1) + (w_2 \cdot x_2) + b\)</div>
        <div id="output-z">Gewichtete Summe (z): berechne...</div>
        <hr style="border: none; border-top: 1px solid #ccc; margin: 10px 0;">
        <!-- Updated formula with MathJax -->
        <div class="formula">\(a = \varphi(z)\) = <i>(Sigmoid)</i></div>
        <div id="output-a">Aktivierung (a): berechne...</div>
    </div>

  

    

    <script>
        // JS Logic updated to output MathJax strings
        (function() {
            const container = document.getElementById('neuron-simulation');
            if (!container) return;

            // Input Elements
            const inputX1 = container.querySelector('#input-x1');
            const inputX2 = container.querySelector('#input-x2');
            const sliderW1 = container.querySelector('#slider-w1');
            const sliderW2 = container.querySelector('#slider-w2');
            const sliderB = container.querySelector('#slider-b');

            // Value Display Elements
            const valueW1 = container.querySelector('#value-w1');
            const valueW2 = container.querySelector('#value-w2');
            const valueB = container.querySelector('#value-b');

            // Output Display Elements
            const outputZ = container.querySelector('#output-z');
            const outputA = container.querySelector('#output-a');

            // Sigmoid Function (remains the same)
            function sigmoid(z) {
                return 1 / (1 + Math.exp(-z));
            }

            // Update function
            function updateNeuron() {
                // Get current values, parsing as floats, default to 0 if parsing fails
                const x1 = parseFloat(inputX1.value) || 0;
                const x2 = parseFloat(inputX2.value) || 0;
                const w1 = parseFloat(sliderW1.value) || 0;
                const w2 = parseFloat(sliderW2.value) || 0;
                const b = parseFloat(sliderB.value) || 0;

                // Calculate weighted sum (z)
                const z = (w1 * x1) + (w2 * x2) + b;

                // Calculate activation (a)
                const a = sigmoid(z);

                // Update display - showing breakdown for z (with MathJax)
                outputZ.innerHTML = `Gewichtete Summe (\\(z\\)): <br>
                    \\((${w1.toFixed(2)} \\cdot ${x1.toFixed(2)}) + (${w2.toFixed(2)} \\cdot ${x2.toFixed(2)}) + (${b.toFixed(2)}) = \\mathbf{${z.toFixed(4)}}\\)`;

                 // Update display - showing activation calculation (with MathJax)
                 outputA.innerHTML = `Aktivierung (\\(a\\)): <br>
                    \\(\\varphi(${z.toFixed(4)}) = \\mathbf{${a.toFixed(4)}}\\)`;
                
                // Tell MathJax to re-render the updated content
                if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                     MathJax.typesetPromise([outputZ, outputA]);
                }
            }

            // Event Listeners for all inputs/sliders (logic remains the same)
            const controls = [inputX1, inputX2, sliderW1, sliderW2, sliderB];
            controls.forEach(control => {
                control.addEventListener('input', () => {
                    // Update slider value displays specifically
                    if (control.id === 'slider-w1') valueW1.textContent = control.value;
                    if (control.id === 'slider-w2') valueW2.textContent = control.value;
                    if (control.id === 'slider-b') valueB.textContent = control.value;

                    // Recalculate and update outputs
                    updateNeuron();
                });
            });

            // Initial setup (logic remains the same)
            // Set initial slider value displays
             valueW1.textContent = sliderW1.value;
             valueW2.textContent = sliderW2.value;
             valueB.textContent = sliderB.value;
            // Run initial calculation
            updateNeuron();

        })();
    </script>

</div>
<!-- End: Interactive Neuron Simulation -->
  <!-- 4. Guidance Text Area (Updated to use MathJax) -->
        <div class="continue-button" onclick="showNextSection(16)">Weiter</div>
    </section>

    <section id="section16">
<div class="stop-and-think">
            <h3>Innehalten und nachdenken</h3>
            <ul>
            <li>Wie beeinflusst die Erhöhung eines Gewichts \(w\) die Ausgabe \(a\), wenn der zugehörige Eingang \(x\) positiv ist?</li>
            <li>Was ist, wenn \(x\) negativ ist?</li>
            <li>Was bewirkt die Änderung des Bias \(b\) bei der Ausgabe?</li>
            </ul>
         (Hinweis: Sigmoid ist nur eine mögliche Aktivierungsfunktion \(\varphi\).)
        </div>
        <div class="continue-button" onclick="showNextSection(17)">Weiter</div>
    </section>

    <section id="section17">
        <h2>Gelernte vs. feste Teile</h2>
        <p>Bei diesem Beispiel können wir mit allen Parametern experimentieren, aber in echten Netzwerken ist es wichtig zu unterscheiden, was das Netzwerk <em>lernt</em> und was wir <em>auswählen</em>.</p>
        <ul>
            <li><strong>Gelernte Parameter:</strong> Die <strong>Gewichte (\(w_i\))</strong> und der <strong>Bias (\(b\))</strong> sind die Parameter, die das Netzwerk während des Trainingsprozesses anpasst, um eine spezifische Aufgabe zu lösen.</li>
            <li><strong>Gewählter Hyperparameter:</strong> Die <strong>Aktivierungsfunktion (\(\varphi\))</strong> wird typischerweise vom Netzwerkdesigner im Voraus ausgewählt (obwohl es fortgeschrittene Techniken gibt, bei denen auch dies gelernt werden kann). Unterschiedliche Wahlen von \(\varphi\) eignen sich für verschiedene Aufgaben oder Netzwerkschichten.</li>
        </ul>
        <div class="continue-button" onclick="showNextSection(18)">Weiter</div>
    </section>

    <section id="section18">
        <div class="faq-section">
            <h3>Häufig gestellte Fragen (FAQ)</h3>
            <h4>Warum brauchen wir den Bias-Term? Können wir nicht einfach die Gewichte anpassen?</h4>
            <p>Super Frage! Stell dir die gewichtete Summe \(\sum(w_i x_i)\) als eine Linie oder Ebene (in höheren Dimensionen) vor. Der Bias \(b\) erlaubt uns, diese Linie/Ebene zu <em>verschieben</em>. Ohne den Bias müsste die vom Neuron erzeugte Entscheidungsgrenze immer durch den Ursprung verlaufen (wo alle Eingaben null sind). Der Bias gibt dem Neuron mehr Flexibilität, seine Entscheidungsgrenze dort zu platzieren, wo sie am besten zur Trennung der Daten benötigt wird.</p>
        </div>
        <div class="continue-button" onclick="showNextSection(19)">Weiter</div>
    </section>

    <section id="section19">
        <h2>Zusammenfassung der Lektion</h2>
        <p>Großartig! Wir haben das künstliche Neuron entschlüsselt:</p>
        <ul>
            <li><strong>Inspiration:</strong> Es basiert lose auf biologischen Neuronen (Eingabe -> Verarbeitung -> Ausgabe).</li>
            <li><strong>Komponenten:</strong> Es hat Eingänge (\(x_i\)), Gewichte (\(w_i\)), einen Bias (\(b\)), einen Summationsschritt (\(z\)), eine Aktivierungsfunktion (\(\varphi\)) und eine Ausgabe (\(a\)).</li>
            <li><strong>Berechnung:</strong> Es berechnet \(a = \varphi( \sum w_i x_i + b )\).</li> <!-- Simplified from display math -->
            <li><strong>Lernen:</strong> Gewichte und Bias werden gelernt; die Aktivierungsfunktion wird normalerweise gewählt.</li>
        </ul>
        <div class="continue-button" onclick="showNextSection(20)">Weiter</div>
    </section>

    <section id="section20">
        <div class="test-your-knowledge">
            <h3>Teste dein Wissen</h3>
            <h4>Was ist der Hauptzweck der Gewichte (\(w_i\)) in einem künstlichen Neuron?</h4>
            <div class="option" onclick="selectOption(1)">Das grundlegende Aktivierungslevel des Neurons festlegen.</div>
            <div class="option" onclick="selectOption(2)">Den Einfluss oder die Bedeutung jedes entsprechenden Eingangs \(x_i\) steuern.</div>
            <div class="option" onclick="selectOption(3)">Eine nichtlineare Transformation auf das summierte Signal anwenden.</div>
            <div class="option" onclick="selectOption(4)">Sicherstellen, dass die Ausgabe immer positiv ist.</div>
            
            <div id="feedback-1" class="option-feedback incorrect">
                <p>Das ist eher die Rolle des Bias \(b\).</p>
            </div>
            <div id="feedback-2" class="option-feedback correct">
                <p>Korrekt! Gewichte bestimmen, wie stark jeder Eingang zum gesamten Aktivierungssignal \(z\) des Neurons beiträgt.</p>
            </div>
            <div id="feedback-3" class="option-feedback incorrect">
                <p>Das ist die Aufgabe der Aktivierungsfunktion \(\varphi\).</p>
            </div>
            <div id="feedback-4" class="option-feedback incorrect">
                <p>Der Wertebereich der Ausgabe hängt ganz von der gewählten Aktivierungsfunktion \(\varphi\) ab.</p>
            </div>
        </div>
        <div class="continue-button" onclick="showNextSection(21)">Weiter</div>
    </section>

    <section id="section21">
        <p>Wir verstehen jetzt den grundlegenden Baustein. In der nächsten Lektion sehen wir, wie wir diese Neuronen zu Schichten verbinden, um leistungsstarke Neuronale Netze zu erstellen!</p>
        <div class="continue-button" onclick="showNextSection(22)">Weiter</div>
    </section>

      <section id="section22">
        <p>Hier geht's zum Fragebogen!</p>
        <p>Anmelden unter <a href="https://www.menti.com">menti.com</a> | Code 4126 5847 verwenden.</p>
        <p>oder</p>
        <div class="image-placeholder">
            <!-- Alt text translated -->
            <img src="images/3.png?height=300&width=600" alt="...">
        </div>
    </section>

    <script>
        // JS for section reveal, answer reveal, quiz selection remains the same.
        // Interactive neuron JS is updated within its section (13).
        document.getElementById("section1").style.display = "block";
        document.getElementById("section1").style.opacity = "1";

        function showNextSection(nextSectionId) {
            const currentButton = event.target;
            const nextSection = document.getElementById("section" + nextSectionId);
            
            currentButton.style.display = "none";
            
            nextSection.style.display = "block";
            setTimeout(() => {
                nextSection.style.opacity = "1";
            }, 10);

            setTimeout(() => {
                nextSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
            }, 500);
        }

        function revealAnswer(id) {
            const revealText = document.getElementById(id);
            const revealButton = event.target;
            
            revealText.style.display = "block";
            revealButton.style.display = "none";
        }

        function selectOption(optionNumber) {
            // Clear previous selections
            const options = document.querySelectorAll('.option');
            options.forEach(option => {
                option.classList.remove('selected');
            });
            
            // Hide all feedback
            const feedbacks = document.querySelectorAll('.option-feedback');
            feedbacks.forEach(feedback => {
                feedback.style.display = 'none';
            });
            
            // Select the clicked option
            event.target.classList.add('selected');
            
            // Show the feedback for the selected option
            const feedbackEl = document.getElementById('feedback-' + optionNumber);
            feedbackEl.style.display = 'block';
            // Rerender MathJax for feedback if needed
            if (typeof MathJax !== 'undefined' && MathJax.typesetPromise) {
                 MathJax.typesetPromise([feedbackEl]);
            }
        }
    </script>
</body>
</html>
